import re
import logging
import argparse
import ipaddress
import os
import sys

from typing import List

BANNER = r"""

  _               _               _                  _
 | |__   ___  ___| |_    _____  _| |_ _ __ __ _  ___| |_ ___  _ __
 | '_ \ / _ \/ __| __|  / _ \ \/ / __| '__/ _` |/ __| __/ _ \| '__|
 | | | | (_) \__ \ |_  |  __/>  <| |_| | | (_| | (__| || (_) | |
 |_| |_|\___/|___/\__|  \___/_/\_\\__|_|  \__,_|\___|\__\___/|_|


"""


class LoggingManager:
    """
    Initialize the logger instance

    Returns:
    - The logger associated with this module
    """
    def __init__(self, name: str ="HostExtractor", level: int = logging.INFO):
        self.logger = logging.getLogger(name)
        self.logger.setLevel(level)

        if not self.logger.hasHandlers():
            handler = logging.StreamHandler()
            formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
            handler.setFormatter(formatter)
            self.logger.addHandler(handler)

    def get_logger(self) -> logging.Logger:
        return self.logger

class HostExtractor:
    def __init__(self, input_path, output_path=None):
        self.input_path = input_path
        self.output_path = output_path
        self.raw_text = ""
        self.cleaned_text = ""
        self.hosts = set()
        self.logger = LoggingManager().get_logger()

    def load_file(self) -> None:
        """
        Loads an file from input stream
        """

        try:
            with open(self.input_path, 'r', encoding='utf-8') as file:
                self.raw_text = file.read()
        except FileNotFoundError:
            self.logger.error(f"File not found: {self.input_path}. Check if you provided the correct path")
        except IOError:
            self.logger.error(f"I/O Error occured when reading {self.file_path}. Exiting")

    def remove_ansi_codes(self) -> None:
        """
        Removes ansi_codes from output generated by amass like 92m, 97m etc.
        """

        self.cleaned_text = re.sub(r'\x1b\[\d{1,3}m|\d{2}m', '', self.raw_text)

    def is_valid_ip(self, ip: str) -> bool:
        """
        Checks and validates if valid ip on regex pattern
        """

        try:
            ipaddress.ip_address(ip)
            return True
        except ValueError:
            return False

    def extract_hosts(self) -> None:
        """
        Extract hosts from the file based on a two patterns.
        """

        lines = self.cleaned_text.splitlines()

        # IPv4 pattern
        ip4_pattern = r'\b(?:\d{1,3}\.){3}\d{1,3}\b'

        # IPv6 (compressed & full, supports "::", hextets, etc.)
        ip6_pattern = r'\b(?:[A-Fa-f0-9]{1,4}:){1,7}[A-Fa-f0-9]{1,4}\b|\b::(?:[A-Fa-f0-9]{1,4}:){0,6}[A-Fa-f0-9]{1,4}?\b'

        # Gets all possible domains - e.g., what its pointing to and etc - to be used in httpx
        fqdn_pattern = r'\b(?:[a-zA-Z0-9-]+(?:-[a-zA-Z0-9-]+)*\.)+[a-zA-Z]{2,}\b'

        for line in lines:
            # Handle "Netblock --> contains --> IP" lines
            if '--> contains -->' in line:
                match = re.search(r'-->\s*contains\s*-->\s*(' + ip4_pattern + r'|' + ip6_pattern + r')', line)
                if match and self.is_valid_ip(match.group(1)):
                    self.hosts.add(match.group(1))
                continue

            # Extract FQDNs and IPs from other lines
            matches = re.findall(f"{fqdn_pattern}|{ip4_pattern}|{ip6_pattern}", line)
            for match in matches:
                # Exclude reverse dns lookup domains
                if not match.endswith('.in-addr.arpa'):
                    self.hosts.add(match)

    def get_host(self) -> List[str]:
        """
        Returns a sorted list of unique extracted hosts (FQDNs + IPs).
        """

        return sorted(self.hosts)

    def write_output(self) -> None:
        """
        Writes output to a file for further iteration
        """

        output = self.get_host()
        if self.output_path:
            with open(self.output_path, "w") as f:
                f.writelines(item + "\n" for item in output)
            self.logger.info(f"Output written to: {self.output_path}")
        else:
            for item in output:
                self.logger.info(item)

    def run(self) -> None:
        """
        Main runner
        """

        self.load_file()
        self.remove_ansi_codes()
        self.extract_hosts()
        self.write_output()

class ArgumentParser:
    """
    Handles argument parsing
    """

    def __init__(self):
        self.parser = self.create_parser()

    def create_parser(self) -> argparse.ArgumentParser:
        """
        Configures the argument parser with expected arguments.

        Returns:
        - An instance of argparse.ArgumentParser
        """

        parser = argparse.ArgumentParser(
                description="Extract Hosts from a file with optional ANSI codes.",
                formatter_class=argparse.RawDescriptionHelpFormatter,
                epilog=BANNER
                )

        parser.add_argument(
                "-i", 
                "--input", 
                required=True, 
                type=str,
                help="Path to input file")

        parser.add_argument(
                "-o", 
                "--output", 
                type=str,
                help="Path to output file (optional)")

        return parser

    def parse_args(self) -> argparse.Namespace:
        return self.parser.parse_args()


class ExtractHostApp:
    def __init__(self):
        """
        Initialize the app, including argument parsing and searcher
        """

        parser = ArgumentParser()
        args = parser.parse_args()

        self.searcher = HostExtractor(input_path=args.input, output_path=args.output)

    def run(self):
        """
        Runs the main application
        """

        self.searcher.run()

def main():
    try:
        app = ExtractHostApp()
        app.run()
    except KeyboardInterrupt:
        print("\nOperation cancelled by the user")
        sys.exit(1)
    except Exception as e:
        logging.error(f"Unexpected error")
        sys.exit(1)

if __name__ == "__main__":
    main()

