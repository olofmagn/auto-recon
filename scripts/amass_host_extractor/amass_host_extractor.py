import re
import logging
import argparse
import ipaddress
import os
import sys

from typing import List

BANNER = r"""

  _               _               _                  _
 | |__   ___  ___| |_    _____  _| |_ _ __ __ _  ___| |_ ___  _ __
 | '_ \ / _ \/ __| __|  / _ \ \/ / __| '__/ _` |/ __| __/ _ \| '__|
 | | | | (_) \__ \ |_  |  __/>  <| |_| | | (_| | (__| || (_) | |
 |_| |_|\___/|___/\__|  \___/_/\_\\__|_|  \__,_|\___|\__\___/|_|


"""

class LoggingManager:
    """
    Initialize the logger instance

    Returns:
    - The logger associated with this module
    """

    def __init__(self, name: str ="HostExtractor", level: int = logging.INFO) -> None:
        self.logger = logging.getLogger(name)
        self.logger.setLevel(level)

        if not self.logger.hasHandlers():
            handler = logging.StreamHandler()
            formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
            handler.setFormatter(formatter)
            self.logger.addHandler(handler)

    def get_logger(self) -> logging.Logger:
        return self.logger

class HostExtractor:
    def __init__(self, input_file: str, output_file: str = None) -> None:
        """
        Initialize the HostExtractor object.

        Args:
        - input_file (str): input file to process
        - output_file (str): output file to write.
        """

        self.input_file = input_file
        self.output_file = output_file
        self.raw_text = ""
        self.cleaned_text = ""
        self.hosts = set()
        self.logger = LoggingManager().get_logger()

    def _load_file(self) -> None:
        """
        Loads an file from input stream.
        """

        try:
            with open(self.input_file, 'r', encoding='utf-8') as file:
                self.raw_text = file.read()
        except FileNotFoundError:
            self.logger.error(f"File not found: {self.input_file}. Check if you provided the correct path")
        except IOError:
            self.logger.error(f"I/O Error occured when reading {self.input_file}. Exiting")

    def _write_output(self) -> None:
        """
        Writes output to a file or console.
        """

        output = self._get_host()
        count = len(output)

        if self.output_file:
            with open(self.output_file, "w", encoding='utf-8') as f:
                f.writelines(item + "\n" for item in output)
            self.logger.info(f"Found {count} hosts written to: {self.output_file}")
        else:
            for item in output:
                self.logger.info(item)
            self.logger.info(f"Found {count} hosts for {self.input_file}")


    def _remove_ansi_codes(self) -> None:
        """
        Removes ansi_codes from output generated by amass like 92m, 97m etc.
        """

        self.cleaned_text = re.sub(r'\x1b\[\d{1,3}m|\d{2}m', '', self.raw_text)

    def _is_valid_ip(self, ip: str) -> bool:
        """
        Checks and validates if valid ip on regex pattern
        """

        try:
            ipaddress.ip_address(ip)
            return True
        except ValueError:
            return False

    def _extract_hosts(self) -> None:
        """
        Extract hosts from the file based on a two patterns.
        """

        lines = self.cleaned_text.splitlines()

        # IPv4/IPv6 pattern. Does not need to be perfect since we validate with ipaddress afterwards
        ipv4_pattern = r'\b(?:\d{1,3}\.){3}\d{1,3}\b'
        ipv6_pattern = r'\b(?:[A-Fa-f0-9]{0,4}:){2,7}[A-Fa-f0-9]{0,4}\b'

        # Gets all possible domains - e.g., what its pointing to and etc - to be used in httpx
        fqdn_pattern = r'\b(?:[a-zA-Z0-9-]+(?:-[a-zA-Z0-9-]+)*\.)+[a-zA-Z]{2,}\b'

        for line in lines:
            # Handle "Netblock --> contains --> IP" lines
            if '--> contains -->' in line:
                match = re.search(r'-->\s*contains\s*-->\s*(' + ipv4_pattern + r'|' + ipv6_pattern + r')', line)
                if match and self._is_valid_ip(match.group(1)):
                    self.hosts.add(match.group(1))
                continue

            # Extract FQDNs and IPs from other lines
            matches = re.findall(f"{fqdn_pattern}|{ipv4_pattern}|{ipv6_pattern}", line)
            for match in matches:
                # Exclude reverse dns lookup domains
                if not match.endswith('.in-addr.arpa'):
                    self.hosts.add(match)

    def _get_host(self) -> List[str]:
        """
        Returns a sorted list of unique extracted hosts (FQDNs + IPs).
        """

        return sorted(self.hosts)

    def run(self) -> None:
        """
        Main runner
        """

        self._load_file()
        self._remove_ansi_codes()
        self._extract_hosts()
        self._write_output()

class ArgumentParser:
    """
    Handles argument parsing
    """

    def __init__(self) -> None:
        self.parser = self.create_parser()

    def create_parser(self) -> argparse.ArgumentParser:
        """
        Configures the argument parser with expected arguments.

        Returns:
        - An instance of argparse.ArgumentParser
        """

        parser = argparse.ArgumentParser(
                description="Extract Hosts from a file with optional ANSI codes.",
                formatter_class=argparse.RawDescriptionHelpFormatter,
                epilog=BANNER
                )

        parser.add_argument(
                "-i", 
                "--input", 
                required=True, 
                type=str,
                help="Path to input file")

        parser.add_argument(
                "-o", 
                "--output", 
                type=str,
                help="Path to output file (optional)")

        return parser

    def parse_args(self) -> argparse.Namespace:
        return self.parser.parse_args()


class ExtractHostApp:
    def __init__(self) -> None:
        """
        Initialize the app, including argument parsing and searcher
        """

        parser = ArgumentParser()
        args = parser.parse_args()

        self.searcher = HostExtractor(input_file=args.input, output_file=args.output)

    def run(self) -> None:
        """
        Runs the main application
        """

        self.searcher.run()

def main():
    try:
        app = ExtractHostApp()
        app.run()
    except KeyboardInterrupt:
        print("\nOperation cancelled by the user")
        sys.exit(1)
    except Exception as e:
        logging.error(f"Unexpected error occured: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main()

